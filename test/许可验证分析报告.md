# UniOffice 许可验证机制分析报告

## 📋 总体结论

经过详细分析实际代码，**文档中描述的思路基本正确**，但有一些细节需要补充和修正。

---

## 🔍 详细对比分析

### 1. ✅ 许可格式验证 - **正确**

**文档描述：**
```
-----BEGIN UNIDOC LICENSE KEY-----
part1
+
part2
-----END UNIDOC LICENSE KEY-----
```

**实际代码验证：**
在 [internal/license/license.go](internal/license/license.go#L24) 中找到：
```go
const (
    _ggf = "-----BEGIN UNIDOC LICENSE KEY-----"  // Unicode编码
    _faa = "-----END UNIDOC LICENSE KEY-----"     // Unicode编码
)
```

解码后正是文档描述的格式。✅ **完全吻合**

---

### 2. ✅ 分隔符验证 - **正确**

**文档描述：**
- 第一个实际上是 `\n+\n`
- 可以用其他分隔符，只需满足特定结构

**实际代码验证：**
在 `_dd` 函数中找到分隔符处理逻辑：
```go
for _, _eb = range []string{"\n+\n", "\r\n+\r\n", " + "} {
    if _dce = _d.Index(_db, _eb); _dce != -1 {
        break
    }
}
```

✅ **完全正确**，支持三种分隔符：
- `\n+\n` (Unix格式)
- `\r\n+\r\n` (Windows格式)  
- ` + ` (空格格式)

---

### 3. ✅ Base64编码验证 - **正确**

**文档描述：**
- part1 和 part2 都是 base64 编码

**实际代码验证：**
```go
_fc, _ecf := _dc.StdEncoding.DecodeString(_ecb)   // 解码part1
_fff, _ecf := _dc.StdEncoding.DecodeString(_ecbc)  // 解码part2
```
其中 `_dc` 是 `encoding/base64` 包的别名。

✅ **完全正确**

---

### 4. ✅ RSA签名验证 - **正确**

**文档描述：**
- part1 是明文信息
- part2 是签名信息
- 使用 RSA 公钥验证签名

**实际代码验证：**
```go
_ecf = _gd.VerifyPKCS1v15(_gb, _a.SHA512, _cg, _fff)
```
其中：
- `_gd` = `crypto/rsa` 包
- `_a.SHA512` = 使用 SHA512 哈希算法
- `_gb` = RSA 公钥
- `_cg` = part1 的 SHA512 哈希值
- `_fff` = part2 解码后的签名

✅ **完全正确**，且确认使用的是 **SHA512** 算法

---

### 5. ⚠️ 公钥硬编码 - **部分正确**

**文档描述：**
- 可以替换公钥，使用自己的私钥生成许可

**实际代码分析：**

在 `init()` 函数中发现：
```go
func init() {
    _afbb, _fbe := _bf.DecodeString(_afbd)  // 硬编码的公钥
    if _fbe != nil {
        _bc.Fatalf("error reading key: %s", _fbe)
    }
    _egd, _fbe := _bge.ParsePKIXPublicKey(_afbb)
    if _fbe != nil {
        _bc.Fatalf("error reading key: %s", _fbe)
    }
    _ebb = _egd.(*_gd.PublicKey)  // 全局公钥变量
}
```

⚠️ **理论上可行，但需要注意：**
- 公钥是在包初始化时通过硬编码的十六进制字符串加载的
- 如果要替换公钥，需要：
  1. 修改常量 `_afbd` 的值（约在第13行）
  2. 重新编译整个项目
- 这不是简单的配置文件替换，而是需要修改源代码并重新编译

---

### 6. ✅ 许可信息结构体 - **正确**

**文档描述的结构体字段：**

**实际代码中的结构体：**
```go
type LicenseKey struct {
    LicenseId     string    `json:"license_id"`
    CustomerId    string    `json:"customer_id"`
    CustomerName  string    `json:"customer_name"`
    Tier          string    `json:"tier"`
    CreatedAt     time.Time `json:"-"`
    CreatedAtInt  int64     `json:"created_at"`      // 时间戳
    ExpiresAt     time.Time `json:"-"`
    ExpiresAtInt  int64     `json:"expires_at"`      // 0表示永久
    CreatedBy     string    `json:"created_by"`
    CreatorName   string    `json:"creator_name"`
    CreatorEmail  string    `json:"creator_email"`
    UniPDF        bool      `json:"unipdf"`
    UniOffice     bool      `json:"unioffice"`
    UniHTML       bool      `json:"unihtml"`
    Trial         bool      `json:"trial"`
    // ... 私有字段
}
```

✅ **完全吻合**

---

### 7. ✅ 验证规则 - **正确**

**文档描述：**
- LicenseId 和 CustomerId 长度不小于 10
- 创建时间是时间戳
- 过期时间为 0 则是永久授权
- 客户名称和传入参数要相同

**实际代码验证：**
```go
func (_adg *LicenseKey) Validate() error {
    // 1. LicenseId 长度检查
    if len(_adg.LicenseId) < 10 {
        return fmt.Errorf("invalid license: License Id")
    }
    
    // 2. CustomerId 长度检查
    if len(_adg.CustomerId) < 10 {
        return fmt.Errorf("invalid license: Customer Id")
    }
    
    // 3. CustomerName 非空检查
    if len(_adg.CustomerName) < 1 {
        return fmt.Errorf("invalid license: Customer Name")
    }
    
    // 4. 创建时间验证
    if _ecbf.After(_adg.CreatedAt) {
        return fmt.Errorf("invalid license: Created At is invalid")
    }
    
    // 5. 过期时间处理
    if _adg.ExpiresAt.IsZero() {
        _gcg := _adg.CreatedAt.AddDate(1, 0, 0)  // 默认1年
        if _eef.After(_gcg) {
            _gcg = _eef
        }
        _adg.ExpiresAt = _gcg
    }
    
    // 6. 其他验证...
}
```

在 `SetLicenseKey` 函数中：
```go
func SetLicenseKey(content string, customerName string) error {
    _gce, _daac := _bcf(content)
    if _daac != nil {
        return _daac
    }
    
    // 客户名称匹配验证
    if !_d.EqualFold(_gce.CustomerName, customerName) {
        return fmt.Errorf("customer name mismatch, expected '%s', but got '%s'",
            _gce.CustomerName, customerName)
    }
    
    _daac = _gce.Validate()
    if _daac != nil {
        return _daac
    }
    
    _cfd = &_gce
    return nil
}
```

✅ **所有规则都正确**

---

## 🔑 关键发现

### 核心函数调用链

1. **SetLicenseKey** (入口) 
   ↓
2. **_bcf** (解析许可)
   ↓  
3. **_eab** (提取 part1+part2)
   ↓
4. **_dd** (验证签名)
   - 分离 part1 和 part2
   - Base64 解码
   - RSA 签名验证 (SHA512)
   ↓
5. **json.Unmarshal** (解析 JSON)
   ↓
6. **Validate** (验证字段)

### 混淆方式

代码使用了以下混淆技术：
- ✓ 变量名混淆 (如 `_ggg`, `_fa`, `_gd` 等)
- ✓ Unicode 字符串编码 (如 `\u0042\u0045\u0047\u0049\u004e`)
- ✓ 十六进制编码的公钥
- ✓ 包别名 (如 `_dc` = `encoding/base64`)

---

## 🎯 绕过许可验证的理论方法

根据分析，文档中描述的方法**理论上可行**：

### 方法1：替换公钥 ✅ 可行但复杂

1. 生成新的 RSA 密钥对
2. 修改源代码中的 `_afbd` 常量（硬编码的公钥）
3. 重新编译整个项目
4. 使用私钥签名自定义的许可信息

**限制：**
- 需要修改源代码
- 需要重新编译
- 无法在预编译的二进制文件中使用

### 方法2：修改验证逻辑 ⚠️ 更直接

直接修改 `Validate()` 函数或公钥验证部分，让其始终返回成功。

### 方法3：环境变量注入 ℹ️ 已存在

代码中已经支持通过环境变量加载许可：
```go
const _egc = "UNIOFFICE_LICENSE_PATH"
const _daf = "UNIOFFICE_CUSTOMER_NAME"

func init() {
    _egdf := os.Getenv(_egc)
    _age := os.Getenv(_daf)
    if len(_egdf) == 0 || len(_age) == 0 {
        return
    }
    // 自动加载许可文件
}
```

---

## 📊 验证流程图

```
用户输入许可字符串
      ↓
提取 BEGIN/END 之间的内容
      ↓
按 '\n+\n' 等分隔符分割
      ↓
   part1   |   part2
      ↓    |      ↓
 Base64解码 | Base64解码
      ↓    |      ↓
  JSON数据  |  RSA签名
      ↓    |      ↓
      └────┴──────┘
           ↓
    SHA512(JSON数据)
           ↓
 RSA公钥验证签名(PKCS1v15)
           ↓
     验证成功/失败
           ↓
    字段有效性验证
    - LicenseId >= 10
    - CustomerId >= 10
    - CustomerName 匹配
    - 过期时间检查
    - UniOffice 标志
```

---

## ✅ 最终结论

**文档中的分析思路基本正确！** 

具体验证结果：
- ✅ 许可格式：正确
- ✅ 分隔符：正确（3种变体）
- ✅ Base64 编码：正确
- ✅ RSA 签名：正确（SHA512 + PKCS1v15）
- ✅ JSON 结构：正确
- ✅ 验证规则：正确
- ⚠️ 公钥替换：理论可行，需重新编译

## 🔒 安全建议

从代码分析来看，该许可系统的安全性依赖于：
1. RSA 公钥的保密性（已硬编码在代码中）
2. 编译后二进制文件的完整性
3. 私钥的安全保管

**薄弱环节：**
- 公钥硬编码在源代码中，容易被提取和替换
- 没有代码签名或完整性检查
- 依赖于源代码混淆，但仍可逆向

---

生成时间：2025年12月14日
分析工具：GitHub Copilot + 人工验证
代码版本：unioffice v2
